#!/usr/bin/python
#+
# Perform common file-manipulation operations on the Lego Mindstorms NXT controller.
#
# Created 2010 February 2 by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

from __future__ import \
	division, \
	with_statement
import sys
import time
import getopt
import nxt.locator
import nxt.brick
import nxt.error

sock = None

#+
# Common command-related definitions
#-

def get_bool(boolstr, default) :
	"""interprets boolstr as yes/no, true/false etc."""
	result = default # initial assumption
	if boolstr != None :
		boolstr = boolstr[0].lower()
		if boolstr == "y" or boolstr == "t" or boolstr == "1" :
			result = True
		elif boolstr == "n" or boolstr == "f" or boolstr == "0" :
			result = False
		#end if
	#end if
	return result
#end get_bool

#+
# Definitions of valid commands.
#
# Each command function is passed two arguments: the first is
# the list of positional arguments, and the second is the
# dictionary of option keywords and corresponding values
# that were specified.
#-

def cmd_help(args, opts) :
	"""shows the user the help description for a command, or for the help
	command itself if no valid command is given."""
	command_candidates = None
	command_match = None
	if len(args) == 1 :
		cmd = args[0]
		if not recognized_commands.has_key(cmd) :
			command_match = cmd
			cmd = None
			command_candidates = list \
			  (
				c for c in recognized_commands.keys()
				if fnmatch.fnmatch(c, command_match)
			  )
		#end if
	else :
		cmd = "help"
		command_candidates = recognized_commands.keys()
	#end if
	if cmd != None :
		sys.stderr.write \
		  (
				"Usage:\n\n\t%s %s %s\n\n%s.\n"
			%
				(
					sys.argv[0],
					cmd,
					recognized_commands[cmd]["help_usage"],
					recognized_commands[cmd]["help_descr"],
				)
		  )
	#end if
	if command_candidates != None :
		if len(command_candidates) != 0 :
			sys.stderr.write \
			  (
					"\nValid commands%(matching)s are: %(commands)s.\n"
				%
					{
						"matching" :
							["", " matching \"%s\"" % command_match][command_match != None],
						"commands" : ", ".join(sorted(command_candidates)),
					}
			  )
		else :
			sys.stderr.write("No commands matching \"%s\".\n" % command_match)
		#end if
	#end if
#end cmd_help

def cmd_name(args, opts) :
	"""gets the existing controller name or sets a new name."""
	old_name = brick.get_device_info()[0]
	if len(args) > 0 :
		new_name = args[0][:len(old_name)]
		brick.set_brick_name(new_name + "\x00" * (len(old_name) - len(new_name)))
	else :
		sys.stdout.write(old_name.rstrip("\x00") + "\n")
	#end if
#end cmd_name

def cmd_hostid(args, opts) :
	"""gets the controller host ID."""
	sys.stdout.write(brick.get_device_info()[1] + "\n")
#end cmd_hostid

def cmd_battery_level(args, opts) :
	"""shows the remaining battery level."""
	sys.stdout.write("Battery level: %d\n" % brick.get_battery_level())
	  # what are the units?
#end cmd_battery_level

def cmd_df(args, opts) :
	"""shows available free space."""
	sys.stdout.write("Available: %d\n" % brick.get_device_info()[3])
#end cmd_df

def cmd_ls(args, opts) :
	"""lists files matching one or more patterns."""
	if len(args) == 0 :
		args = ["*.*"]
	#end if
	nxt_sector_size = 256
	found_one = False
	totalsize = 0
	totalalloc = 0
	for p in args :
		try :
			for filename, filesize in nxt.brick.FileFinder(brick, p) :
				allocsize = (filesize + nxt_sector_size - 1) // nxt_sector_size * nxt_sector_size
				sys.stdout.write("%6d/%6d %s\n" % (filesize, allocsize, filename.rstrip("\x00")))
				totalsize += filesize
				totalalloc += allocsize
				found_one = True
			#end for
		except nxt.error.FileNotFound :
			pass # go on to the next pattern
		#end try
	#end for
	if found_one :
		sys.stdout.write("%6d/%6d\n" % (totalsize, totalalloc))
	else :
		sys.stdout.write("no matches found\n")
	#end if
#end cmd_ls

def cmd_download(args, opts) :
	"""downloads a file to standard output."""
	with nxt.brick.FileReader(brick, args[0]) as thefile :
		for block in thefile :
			sys.stdout.write(block)
		#end for
	#end with
#end cmd_download

def cmd_upload(args, opts) :
	"""uploads a file from standard input."""
	with nxt.brick.FileWriter(brick, args[0], sys.stdin) as thefile :
		for dummy in thefile :
			pass
		#end for
	#end with
#end cmd_upload

def cmd_rm(args, opts) :
	"""deletes the single file with the specified name."""
	brick.delete(args[0])
#end cmd_rm

def cmd_soundfile(args, opts) :
	"""plays a soundfile."""
	brick.play_sound_file \
	  (
		get_bool(opts.get("loop"), False),
		args[0]
	  )
#end cmd_soundfile

def cmd_playtones(args, opts) :
	"""plays one or more tones."""
	if len(args) % 2 != 0 :
		raise getopt.GetoptError("need an even number of args")
	#end if
	while len(args) > 0 :
		freq, dur = args[:2]
		args = args[2:]
		brick.play_tone(int(freq), int(dur))
		time.sleep(int(dur) / 1000) # wait for tone to finish before next
	#end while
#end cmd_playtones

recognized_commands = \
  {
# key is command name, value is dictionary with following fields:
#     args -- nr required positional args, or tuple of min and max nr required positional args
#     opts -- tuple of long option names. If a name ends in an equal sign, then it takes a value.
#     multivalued -- optional tuple of option keywords which can occur multiple times
#     required -- optional tuple of option keywords which must be present
#     help_usage -- used to construct a usage string when giving help for the command.
#     help_descr -- explanatory text shown when giving help for the command.
#     action -- the function to invoke to actually perform the command.
#     connect -- whether to actually open the connection to the NXT controller.
#         If omitted, defaults to True.
#
# This whole structure is adapted from my geek_central project.

	"help" :
	  {
		"args" : (0, 1),
		"opts" : (),
		"action" : cmd_help,
		"help_usage" : "[cmd]",
		"help_descr" : "gives help about the specified command",
		"connect" : False,
	  },

# miscellaneous

	"name" :
	  {
		"args" : (0, 1), # optional new name
		"opts" : (),
		"action" : cmd_name,
		"help_usage" : "[newname]",
		"help_descr" : "gets the existing name of the controller, or sets a new name",
	  },

	"hostid" :
	  {
		"args" : 0,
		"opts" : (),
		"action" : cmd_hostid,
		"help_usage" : "",
		"help_descr" : "returns the controller's host ID",
	  },

	"battery" :
	  {
		"args" : 0,
		"opts" : (),
		"action" : cmd_battery_level,
		"help_usage" : "",
		"help_descr" : "shows the battery level remaining",
	  },

# filesystem

	"df" :
	  {
		"args" : 0,
		"opts" : (),
		"action" : cmd_df,
		"help_usage" : "",
		"help_descr" : "shows total space available",
	  },

	"ls" :
	  {
		"args" : (), # filename(s)
		"opts" : (),
		"action" : cmd_ls,
		"help_usage" : "pattern [pattern...]",
		"help_descr" :
			"lists filenames matching the specified pattern(s).\n"
			"Patterns can be name.ext, name.*, *.ext or *.*",
	  },

	"down" :
	  {
		"args" : 1, # filename
		"opts" : (),
		"action" : cmd_download,
		"help_usage" : "filename",
		"help_descr" : "downloads the file from the NXT and writes it to standard output",
	  },

	"up" :
	  {
		"args" : 1, # filename
		"opts" : (),
		"action" : cmd_upload,
		"help_usage" : "filename",
		"help_descr" : "uploads a file to the NXT by reading from standard input",
	  },

	"rm" :
	  {
		"args" : 1, # filename (1 only)
		"opts" : (),
		"action" : cmd_rm,
		"help_usage" : "filename",
		"help_descr" :
			"deletes the file with the specified name",
	  },

# sound

	"soundfile" :
	  {
		"args" : 1, # filename
		"opts" : ("loop="),
		"action" : cmd_soundfile,
		"help_usage" : "filename [--loop=Y|N]",
		"help_descr" : "plays a sound file with optional looping",
	  },

	"tones" :
	  {
		"args" : (), # frequency, duration ...
		"opts" : (),
		"action" : cmd_playtones,
		"help_usage" : "frequency duration [frequency duration ...]",
		"help_descr" : "plays one or more tones",
	  },

  } # recognized_commands


#+
# Mainline
#-

def mainline() :
	if len(sys.argv) < 2 :
		raise getopt.GetoptError("need at least one arg, the cmd to execute")
	#end if
	cmd = sys.argv[1]
	cmd_entry = recognized_commands.get(cmd)
	if cmd_entry == None :
		raise getopt.GetoptError("unrecognized command %s" % repr(cmd))
	#end if
	(opts_list, args) = getopt.gnu_getopt \
	  (
		sys.argv[2:],
		"",
		cmd_entry["opts"]
	  )
	if type(cmd_entry["args"]) == tuple :
		if len(cmd_entry["args"]) > 1 :
			if \
			  (
					len(args) < cmd_entry["args"][0]
				or
					len(args) > cmd_entry["args"][1]
			  ):
				raise getopt.GetoptError \
				  (
					"%s command needs %u..%u args" % ((cmd,) + cmd_entry["args"])
				  )
			#end if
		#end if
	else :
		if len(args) != cmd_entry["args"] :
			raise getopt.GetoptError \
			  (
				"%s command needs exactly %u args" % (cmd, cmd_entry["args"])
			  )
		#end if
	#end if
	opts = {}
	multi_opts = frozenset(cmd_entry.get("multivalued", ()))
	for keyword, value in opts_list :
		if keyword[:2] == "--" :
			keyword = keyword[2:]
			if keyword in multi_opts :
				values = opts.get(keyword, [])
				values.append(value)
				opts[keyword] = values
			else :
				opts[keyword] = value
			#end if
		#end if
	#end for
	required_opts = cmd_entry.get("required")
	if required_opts != None :
		missing = set(required_opts) - set(opts.keys())
		if len(missing) != 0 :
			raise getopt.GetoptError \
			  (
				"%s command needs option(s) %s" % (cmd, ",".join(tuple(missing)))
			  )
		#end if
	#end if
	if cmd_entry.get("connect", True) :
		global brick, sock
		sock = nxt.locator.find_one_brick()
		brick = sock.connect()
	#end if
	cmd_entry["action"](args, opts) # can raise exceptions
#end mainline

mainline()
if sock != None :
	sock.close()
#end if
