#!/usr/bin/python
#+
# Perform common file-manipulation operations on the Lego Mindstorms NXT controller.
#
# Created by Lawrence D'Oliveiro <ldo@geek-central.gen.nz>.
#-

from __future__ import \
	division, \
	with_statement
import math
import sys
import time
import struct
import subprocess
import getopt
import nxt.locator
import nxt.brick
import nxt.error

#+
# Useful stuff
#-

def structread(fromfile, decode_struct) :
	"""reads sufficient bytes from fromfile to be unpacked according to
	decode_struct, and returns the unpacked results."""
	return struct.unpack(decode_struct, fromfile.read(struct.calcsize(decode_struct)))
#end structread

#+
# Common command-related definitions
#-

def get_bool(boolstr, default) :
	"""interprets boolstr as yes/no, true/false etc."""
	result = default # initial assumption
	if boolstr != None :
		boolstr = boolstr[0].lower()
		if boolstr == "y" or boolstr == "t" or boolstr == "1" :
			result = True
		elif boolstr == "n" or boolstr == "f" or boolstr == "0" :
			result = False
		#end if
	#end if
	return result
#end get_bool

def make_note_converter(opts) :
	"""returns a note-converter function which interprets a note spec
	as a frequency or a note number, depending on opts. The options which
	may be present are:

		--notes
			if present, then interpret the frequency spec as a MIDI note
			number (semitone steps with 60 = middle C). Fractions are allowed,
			but the computed frequency is always an integer.
			If absent, then interpret the frequency spec as integer Hz.
		--tune=notenr:freq
			specifies the tuning for note numbers, as a reference note number
			and the corresponding reference frequency. If omitted, the default is
			69:440 (A above middle C = 440Hz, also known as Concert Pitch).

	"""
	if opts.has_key("notes") :
		refnote, reffreq = opts.get("tune", "69:440").split(":", 1)
		refnote = float(refnote)
		reffreq = float(reffreq)
		def notefn(note) :
			return int(round(2 ** ((float(note) - refnote) / 12) * reffreq))
		#end notefn
	else :
		notefn = int # straight frequency
	#end if
	return notefn
#end make_note_converter

#+
# Globals
#-

sock = None # connection to NXT controller

#+
# Definitions of valid commands.
#
# Each command function is passed two arguments: the first is
# the list of positional arguments, and the second is the
# dictionary of option keywords and corresponding values
# that were specified.
#-

def cmd_help(args, opts) :
	"""shows the user the help description for a command, or for the help
	command itself if no valid command is given."""
	command_candidates = None
	command_match = None
	if len(args) == 1 :
		cmd = args[0]
		if not recognized_commands.has_key(cmd) :
			command_match = cmd
			cmd = None
			command_candidates = list \
			  (
				c for c in recognized_commands.keys()
				if fnmatch.fnmatch(c, command_match)
			  )
		#end if
	else :
		cmd = "help"
		command_candidates = recognized_commands.keys()
	#end if
	if cmd != None :
		sys.stderr.write \
		  (
				"Usage:\n\n\t%s %s %s\n\n%s.\n"
			%
				(
					sys.argv[0],
					cmd,
					recognized_commands[cmd]["help_usage"],
					recognized_commands[cmd]["help_descr"],
				)
		  )
	#end if
	if command_candidates != None :
		if len(command_candidates) != 0 :
			sys.stderr.write \
			  (
					"\nValid commands%(matching)s are: %(commands)s.\n"
				%
					{
						"matching" :
							["", " matching \"%s\"" % command_match][command_match != None],
						"commands" : ", ".join(sorted(command_candidates)),
					}
			  )
		else :
			sys.stderr.write("No commands matching \"%s\".\n" % command_match)
		#end if
	#end if
#end cmd_help

def cmd_name(args, opts) :
	"""gets the existing controller name or sets a new name."""
	old_name = brick.get_device_info()[0]
	if len(args) > 0 :
		new_name = args[0][:len(old_name)]
		brick.set_brick_name(new_name + "\x00" * (len(old_name) - len(new_name)))
	else :
		sys.stdout.write(old_name.rstrip("\x00") + "\n")
	#end if
#end cmd_name

def cmd_hostid(args, opts) :
	"""gets the controller host ID."""
	sys.stdout.write(brick.get_device_info()[1] + "\n")
#end cmd_hostid

def cmd_battery_level(args, opts) :
	"""shows the remaining battery level."""
	sys.stdout.write("Battery level: %d\n" % brick.get_battery_level())
	  # what are the units?
#end cmd_battery_level

def cmd_df(args, opts) :
	"""shows available free space."""
	sys.stdout.write("Available: %d\n" % brick.get_device_info()[3])
#end cmd_df

def cmd_ls(args, opts) :
	"""lists files matching one or more patterns."""
	if len(args) == 0 :
		args = ["*.*"]
	#end if
	nxt_sector_size = 256
	found_one = False
	totalsize = 0
	totalalloc = 0
	for p in args :
		try :
			for filename, filesize in nxt.brick.FileFinder(brick, p) :
				allocsize = (filesize + nxt_sector_size - 1) // nxt_sector_size * nxt_sector_size
				sys.stdout.write("%6d/%6d %s\n" % (filesize, allocsize, filename.rstrip("\x00")))
				totalsize += filesize
				totalalloc += allocsize
				found_one = True
			#end for
		except nxt.error.FileNotFound :
			pass # go on to the next pattern
		#end try
	#end for
	if found_one :
		sys.stdout.write("%6d/%6d\n" % (totalsize, totalalloc))
	else :
		sys.stdout.write("no matches found\n")
	#end if
#end cmd_ls

def cmd_download(args, opts) :
	"""downloads a file to standard output."""
	with nxt.brick.FileReader(brick, args[0]) as thefile :
		for block in thefile :
			sys.stdout.write(block)
		#end for
	#end with
#end cmd_download

def cmd_upload(args, opts) :
	"""uploads a file from standard input."""
	with nxt.brick.FileWriter(brick, args[0], sys.stdin) as thefile :
		for dummy in thefile :
			pass
		#end for
	#end with
#end cmd_upload

def cmd_rm(args, opts) :
	"""deletes the single file with the specified name."""
	brick.delete(args[0])
#end cmd_rm

def cmd_soundfile(args, opts) :
	"""plays a soundfile."""
	brick.play_sound_file \
	  (
		get_bool(opts.get("loop"), False),
		args[0]
	  )
#end cmd_soundfile

def cmd_playtones(args, opts) :
	"""plays one or more tones."""
	if len(args) % 2 != 0 :
		raise getopt.GetoptError("need an even number of args")
	#end if
	notefn = make_note_converter(opts)
	while len(args) > 0 :
		freq, dur = args[:2]
		args = args[2:]
		brick.play_tone(notefn(freq), int(dur))
		time.sleep(int(dur) / 1000) # wait for tone to finish before next
	#end while
#end cmd_playtones

def cmd_tonesfile(args, opts) :
	"""encodes a sequence of tones into a melody file and writes it to standard output.
	Various websites describe this as an .rmd file, but the NXT on-board interface
	will not show it to the user as a sound file unless it has an .rso extension.
	Of course, programmatic commands can access it and play it regardless."""
	if len(args) % 2 != 0 :
		raise getopt.GetoptError("need an even number of args")
	#end if
	notefn = make_note_converter(opts)
	data = ""
	while len(args) > 0 :
		freq, dur = args[:2]
		args = args[2:]
		data += struct.pack(">HH", notefn(freq), int(dur))
	#end while
	sys.stdout.write(struct.pack(">BBHHH", 6, 0, len(data), 0, 0))
	sys.stdout.write(data)
#end cmd_tonesfile

def cmd_soundcvt(args, opts) :
	"""converts between .rso and .wav file formats using sox."""
	infilename, outfilename = args
	rso_version = 1
	if infilename.endswith(".rso") and outfilename.endswith(".wav") :
		infile = open(infilename, "r")
		version, compressed, length, sample_rate, play_mode = structread(infile, ">BBHHH")
		if version != rso_version :
			raise RuntimeError("bad .rso file version")
		#end if
		compressed = compressed != 0
		# FIXME: can't properly decode compressed files
		infmt = \
			(
				"-t", ("raw", "ima")[compressed],
				"-b", ("8", "4")[compressed],
				"-c", "1",
				"-e", ("unsigned-integer", "ima-adpcm")[compressed],
				"-r", "%d" % sample_rate,
			)
		outfmt = \
			(
				"-e", "unsigned-integer",
				"-b", "8",
			)
		child = subprocess.Popen \
		  (
			args = ("sox",) + infmt + ("/dev/stdin",) + outfmt + (outfilename,),
			stdin = subprocess.PIPE,
			close_fds = True
		  )
		child.communicate(infile.read(length))
	elif infilename.endswith(".wav") and outfilename.endswith(".rso") :
		sample_rate = 8000
		play_mode = 0
		compressed = 0 # for now
		child = subprocess.Popen \
		  (
			args =
				(
					"sox",
					infilename,
					"-t", "raw",
					"-b", "8",
					"-c", "1",
					"-e", "signed-integer",
					"-r", "%d" % sample_rate,
					"/dev/stdout",
				),
			stdout = subprocess.PIPE,
			close_fds = True
		  )
		data, _ = child.communicate()
		outfile = open(outfilename, "w")
		outfile.write(struct.pack(">BBHHH", rso_version, compressed, len(data), sample_rate, play_mode))
		outfile.write(data)
		outfile.flush()
		outfile.close()
	else :
		raise getopt.GetoptError("one filename must end in .rso and the other in .wav")
	#end if
#end cmd_soundcvt

recognized_commands = \
  {
# key is command name, value is dictionary with following fields:
#     args -- nr required positional args, or tuple of min and max nr required positional args
#     opts -- tuple of long option names. If a name ends in an equal sign, then it takes a value.
#     multivalued -- optional tuple of option keywords which can occur multiple times
#     required -- optional tuple of option keywords which must be present
#     help_usage -- used to construct a usage string when giving help for the command.
#     help_descr -- explanatory text shown when giving help for the command.
#     action -- the function to invoke to actually perform the command.
#     connect -- whether to actually open the connection to the NXT controller.
#         If omitted, defaults to True.
#
# This whole structure is adapted from my geek_central project.

	"help" :
	  {
		"args" : (0, 1),
		"opts" : (),
		"action" : cmd_help,
		"help_usage" : "[cmd]",
		"help_descr" : "gives help about the specified command",
		"connect" : False,
	  },

# miscellaneous

	"name" :
	  {
		"args" : (0, 1), # optional new name
		"opts" : (),
		"action" : cmd_name,
		"help_usage" : "[newname]",
		"help_descr" : "gets the existing name of the controller, or sets a new name",
	  },

	"hostid" :
	  {
		"args" : 0,
		"opts" : (),
		"action" : cmd_hostid,
		"help_usage" : "",
		"help_descr" : "returns the controller's host ID",
	  },

	"battery" :
	  {
		"args" : 0,
		"opts" : (),
		"action" : cmd_battery_level,
		"help_usage" : "",
		"help_descr" : "shows the battery level remaining",
	  },

# filesystem

	"df" :
	  {
		"args" : 0,
		"opts" : (),
		"action" : cmd_df,
		"help_usage" : "",
		"help_descr" : "shows total space available",
	  },

	"ls" :
	  {
		"args" : (), # filename(s)
		"opts" : (),
		"action" : cmd_ls,
		"help_usage" : "pattern [pattern...]",
		"help_descr" :
			"lists filenames matching the specified pattern(s).\n"
			"Patterns can be name.ext, name.*, *.ext or *.*",
	  },

	"down" :
	  {
		"args" : 1, # filename
		"opts" : (),
		"action" : cmd_download,
		"help_usage" : "filename",
		"help_descr" : "downloads the file from the NXT and writes it to standard output",
	  },

	"up" :
	  {
		"args" : 1, # filename
		"opts" : (),
		"action" : cmd_upload,
		"help_usage" : "filename",
		"help_descr" : "uploads a file to the NXT by reading from standard input",
	  },

	"rm" :
	  {
		"args" : 1, # filename (1 only)
		"opts" : (),
		"action" : cmd_rm,
		"help_usage" : "filename",
		"help_descr" :
			"deletes the file with the specified name",
	  },

# sound

	"soundfile" :
	  {
		"args" : 1, # filename
		"opts" : ("loop="),
		"action" : cmd_soundfile,
		"help_usage" : "filename [--loop=Y|N]",
		"help_descr" : "plays a sound file with optional looping",
	  },

	"tones" :
	  {
		"args" : (), # frequency, duration ...
		"opts" : ("notes", "tune="),
		"action" : cmd_playtones,
		"help_usage" : "frequency duration [frequency duration ...]",
		"help_descr" : "plays one or more tones",
	  },

	"tonesfile" :
	  {
		"args" : (), # frequency, duration ...
		"opts" : ("notes", "tune="),
		"action" : cmd_tonesfile,
		"help_usage" : "frequency duration [frequency duration ...]",
		"help_descr" :
			"writes a .rmd file to standard output that plays the specified tones"
			" in sequence",
		"connect" : False,
	  },

	"soundcvt" :
	  {
		"args" : 2, # infile outfile
		"opts" : (),
		"action" : cmd_soundcvt,
		"help_usage" : "infile outfile",
		"help_descr" : "converts between .rso and .wav file formats using sox",
		"connect" : False,
	  },

  } # recognized_commands


#+
# Mainline
#-

def mainline() :
	if len(sys.argv) < 2 :
		raise getopt.GetoptError("need at least one arg, the cmd to execute")
	#end if
	cmd = sys.argv[1]
	cmd_entry = recognized_commands.get(cmd)
	if cmd_entry == None :
		raise getopt.GetoptError("unrecognized command %s" % repr(cmd))
	#end if
	(opts_list, args) = getopt.gnu_getopt \
	  (
		sys.argv[2:],
		"",
		cmd_entry["opts"]
	  )
	if type(cmd_entry["args"]) == tuple :
		if len(cmd_entry["args"]) > 1 :
			if \
			  (
					len(args) < cmd_entry["args"][0]
				or
					len(args) > cmd_entry["args"][1]
			  ):
				raise getopt.GetoptError \
				  (
					"%s command needs %u..%u args" % ((cmd,) + cmd_entry["args"])
				  )
			#end if
		#end if
	else :
		if len(args) != cmd_entry["args"] :
			raise getopt.GetoptError \
			  (
				"%s command needs exactly %u args" % (cmd, cmd_entry["args"])
			  )
		#end if
	#end if
	opts = {}
	multi_opts = frozenset(cmd_entry.get("multivalued", ()))
	for keyword, value in opts_list :
		if keyword[:2] == "--" :
			keyword = keyword[2:]
			if keyword in multi_opts :
				values = opts.get(keyword, [])
				values.append(value)
				opts[keyword] = values
			else :
				opts[keyword] = value
			#end if
		#end if
	#end for
	required_opts = cmd_entry.get("required")
	if required_opts != None :
		missing = set(required_opts) - set(opts.keys())
		if len(missing) != 0 :
			raise getopt.GetoptError \
			  (
				"%s command needs option(s) %s" % (cmd, ",".join(tuple(missing)))
			  )
		#end if
	#end if
	if cmd_entry.get("connect", True) :
		global brick, sock
		sock = nxt.locator.find_one_brick()
		brick = sock.connect()
	#end if
	cmd_entry["action"](args, opts) # can raise exceptions
#end mainline

mainline()
if sock != None :
	sock.close()
#end if
